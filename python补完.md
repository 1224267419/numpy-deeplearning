 ```
a='张'
b='三'
print(a+b)
print(a*32)
```
输出
'张三'
'张张张张张张张张张张张张张张张张张张张张张张张张张张张张张张张张‘

数字和字符只能进行+和*两种运算


%s 字符串
%d   十进制证书，%06d表示输出至少6位整数，不足用0补全
%f    浮点数，%.02f表示小数点后两位
%%	输出%


```python
name='张三'

print('%s' %name)
```
输出:
张三

```python
no1=2
no2=100
print('%09d' %no1)
print('%09d' %no2)
print('%9d' %no2)
```
输出:
000000002
000000100
      	   100
不写0也会自动对齐，不过不用0补位

```python
price=2.55
weight=1.3
money=price*weight
print('%f' %money)
print('%.02f' %money)
print('%.2f' %money)#同'%.02f' %money一样
print('%.9f' %money)
```

输出：
3.315000
3.31
3.31
3.315000000

注意
print('%.9f' %money* 10)只会输出10次3.315000000 ， print('%.9f' %(money*10))才是数字  * 10

随机整数:random.randint( a,b )输入a和b(整数)，a必须<=b

```
def lyb(a,b,c):
    '''
    
    :param a: 
    :param b: 
    :param c: 
    :return: 
    '''
    print('lyb')

```
#### 函数注释
直接在函数头下一行打三个引号，自动生成函数注释模板，然后在调用函数时对着函数按CTRL+Q可看注释

##### 模块小细节
使用模块可以使用模块内的函数和变量(模块名.变量(函数)名)，使得函数可以被复用

模块名字不能用数字开头，所以python源文件名最好也不要用数字开头(方便以后调用)

##### 高级变量
通用
len()	元素个数
del()	删除变量
max()	返回最大值	
min()	返回最小值
< > 也可以对list和tuple生效
[,]切片，字典没有顺序，不能切
以下为运算符，返回一个新的东西，不影响被调用的变量
+	合并
*	重复
in	是否存在
not in	是否不存在
in和not in也可以用于字典中，针对key而非值
> < =	比较每一个元素(都符合才True)
###### list方法介绍
https://www.cnblogs.com/keepkeep/p/11573424.html
定义：[]
list.index()   取第一次出现的索引
查找和替换，改变大小写，去除空白字符，拆分和连接，文本对齐


is开头：判断类型(返回T or F)

增加：
```
list.append()	  	#末尾追加数据，即使是列表将列表当成一个数据
list.insert(a,b)	#在a位置插入b
list.extend()		#末尾追加数据或者列表，如果是列表仅插入列表中的 数据
```

删除： 
```
list.clear()   	#删除所有数据
list.pop()		#删除任意一个数据(输入索引)(默认删除最后的元素)
list.remove(a)	#删除数据a(具体数据 )，有多个删除第一个 
del list[1]		#类pop，从内存中删除，也能删除其他变量90(删除变量以后直接无定义) 
```

统计出现次数：
list.count(object)	统计object出现次数     

排序：
list.sort()   						#升序
list.sort(reverse=True)   	#降序
list.reverse()					  #反序，逆序   

元组Tuple：
元组定义用()，元组不能修改某个数据

元组仅含一个元素时，需要在元素后加, ，否则会认为是普通的值
tuple=(5,)

tuple.count()
tuple.index()
元组仅有这俩操作，用法效果同list

```
tuple=('a',2,19.9)
print('%s    %d    %.2f'   %tuple)
info_str='%s    %d    %.2f'   %tuple
print(info_str)
```
输出
a    2    19.90   
a    2    19.90

格式化字符串后面的是元组，直接使用元组也是可行的

修改元组:
转为列表(可修改了)
list(_tuple)
转为元组(不可修改了)
tuple(_list)

##### 字典dictionary
_dic={'name':'小明',
'age':18,
'gender':True,
'height':1.75}

如上创建了一个字典
dic[key]    取值
如：
print(_dic['name'])  
输出：
小明

新增(修改):存在的键值对会修改，不存在的会新增(类似touch)
dic[key]=val

删除元素(通过pop方法)
dic.pop(key)
key不正确会报错 

字典合并：同key的键值对值取dic1的
_dic1.update(_dic2)

清空
_dic1.clear()
 
遍历(没有顺序的，下次遍历可能顺序不一样)
```python
for i in _dic:

	print('%s - %s'		%	(k,_dic1[k]))
```


注意，对于while else 和for else，没有break或者return的话必定触发else的语句

在引用自定义的模块时，模块必须有_下划线


批量修改变量名:右键重构

如果return后面啥都没有，直接结束函数

#### 变量的引用 
```
In [1]: a=1

In [2]: id(a)
Out[2]: 140709731903280

In [3]: id(1)
Out[3]: 140709731903280

In [4]: b=a

In [5]: a=2

In [6]: id(b)
Out[6]: 140709731903280

In [7]: id(a)
Out[7]: 140709731903312
```
如上可知，变量赋值其实只是变量引用了值的位置而言-+
而函数调用的也是实参保存数据的引用，而非实参保存的数据


###### 可变和不可变类型
不可变：内存的数据不能被修改
数字:int bool,float,complex,
字符串：str
元组：tuple
```
a=1				此时1所在的内存数值为一且不能修改，变a的值只是改变a的引用
```
可变：内存的数据可以被修改
列表list
字典dic

改变这俩的值，地址不变，内存的数据变了
```
list.append() 
dic[]=		,d.pop()
```
等**内置方法**都不会改变内存位置,所以可以在函数内改变外面的可变变量
**注意**：对**list使用** **+=**本质是执行extend方法，也不会改变引用
a=[]	使用了新的值（即使是空值）当然就会改变内存位置

而字典中的数据只能使用不可变类型(整数 字符串 元组 )的数据作为key

###### 哈希函数(hash)
接受一个**不可变类型**的数据作为**参数**
返回结果是一个**整数**(特征码)

hash函数：提取数据特征码
**相同内容**得到**相同结果**
**不同内容**得到**不同结果**

字典设置键值对时会对key进行hash，所以必须用不可变类型数据

### 局部变量和全局变量
其他语言都是尽可能使用局部变量，后期好维护 ，python随便一点
**函数内定义**的变量都是**局部变量**
**局部变量**在**函数执行时**才会被**创建**，函数**执行完毕后**就会**被回收**
局部变量用于**存储临时数据**

函数内不能直接修改全局变量的值(会和局部变量的定义和赋值冲突，想要修改请引入参数)，除修改以外的操作基本没问题
使用global可以在函数中使用全局变量，不会创建同名局部变量 
```python
a=10

def change()
	global a
	a=20

change()
print(a)
```

输出：
20

一般代码结构：
shebang
import模块
全局变量 
函数定义
执行代码

一般定义全局变量，可以在命名前加一个g_来明确全局变量身份


返回多个变量

```python 
def f():
    a=10
    b=20
    return a,b	#这里可以用[] ()或者直接省略

a,b=f()
print(a)
print(b)
print(f[0])	#（这种索引也行，不过不好用，还是上面的好）
```
输出：
10
20
10

交换元素
```
a,b=b,a
```
利用元组交换俩元素，仅python，别乱用,	(令opencv里面的r,g,b=b,g,r倒是不错，下次可以试试)

无论你是啥变量，只要没有global就别想用赋值改变外面变量的值(方法可以改可变变量的值，即函数仅不能改外部变量的地址)


#### 缺省参数：即默认参数

for example:
```python
_list.sort()		#其实省略了reverse=False，空白就是默认
_list.sort(reverse=True)	#用的少，所以默认不是你
```

**常用**参数作为默认参数，**简化函数调用**
```python
def function(a=1)

```
如上方法定义即可，缺省参数放最后面；给缺省参数传参，需要放在普通参数的后面，并且有如：
```
reverse=True
```
的形式(形参=传递参数)即可

##### 多值参数

*args	参数名前加一个*，可以接受元组
**kwargs	参数名前加俩个*，可以接受字典
例子：
```python
def demo(num, *nums, **person):

    print(num)
    print(nums)
    print(person)


# demo(1)
demo(1, 2, 3, 4, 5, name="小明", age=18)
```

输出：
1
(2, 3, 4, 5)		 
{'name': '小明', 'age': 18}

```
def sum_numbers(*args):
# def sum_numbers(args):

    num = 0

    print(args)
    # 循环遍历
    for n in args:
        num += n

    return num

result = sum_numbers(1, 2, 3, 4, 5)
print(result)
```
不用*，多加1个括号将元组作为参数输入函数也是可以的，但是就不像加 *这么方便，可以直接导入多个变量

```python
def demo(*args, **kwargs):

    print(args)
    print(kwargs)


# 元组变量/字典变量
gl_nums = (1, 2, 3)
gl_dict = {"name": "小明", "age": 18}

demo(gl_nums, gl_dict)

# 拆包语法，简化元组变量/字典变量的传递
demo(*gl_nums, **gl_dict)

demo(1, 2, 3, name="小明", age=18)
```
输出：
```
((1, 2, 3), {'name': '小明', 'age': 18})
{}
(1, 2, 3)
{'name': '小明', 'age': 18}
(1, 2, 3)
{'name': '小明', 'age': 18}

```
如上，对元组变量加*，字典变量加**进行拆包(实参)，使参数被放在正确的位置上，防止字典变量由于*args的特殊性质导致后面的元素位置不正确

不使用拆包语法的话，就需要将元素拆分，但是这样不方便也不美观


## 递归
函数内部自己调用自己，必须接收参数，当**满足某一条件时，不再执行**，即递归必须有出口(满足某条件，则不再执行

面对不确定的条件时很有用，such as遍历整个文件目录结构，(但是会比正常方法慢)



## 面向对象

 过程：只能执行，没有返回结果
完成的代码就是按顺序不断调用不同函数，但是对于复杂需求代码会很复杂，套路不固定  


面向对象：对象内封装多个方法，最后让对象调用不同方法即可

> 相比较函数，**面向对象** 是 **更大** 的 **封装**，根据 **职责** 在 **一个对象中 封装 多个方法**

1. 在完成某一个需求前，首先确定 **职责** ―― **要做的事情（方法）**
2. 根据 **职责** 确定不同的 **对象**，在 **对象** 内部封装不同的 **方法**（多个）
3. 最后完成的代码，就是顺序地让 **不同的对象** 调用 **不同的方法**

**特点**

1. 注重 **对象和职责**，不同的对象承担不同的职责
2. 更加适合应对复杂的需求变化，**是专门应对复杂项目开发，提供的固定套路**
3. **需要在面向过程基础上，再学习一些面向对象的语法**   

### 1.1 类
* **类** 是对一群具有 **相同 特征** 或者 **行为** 的事物的一个统称，是抽象的，**不能直接使用**
    * **特征** 被称为 **属性**
    * **行为** 被称为 **方法**
* **类** 就相当于制造飞机时的**图纸**，是一个 **模板**，是 **负责创建对象的**



### 1.2 对象

* **对象** 是 **由类创建出来的一个具体存在**，可以直接使用
* 由 **哪一个类** 创建出来的 **对象**，就拥有在 **哪一个类** 中定义的：
    * 属性
    * 方法
* **对象** 就相当于用 **图纸** **制造** 的飞机

> 在程序开发中，应该 **先有类，再有对象**，而一个类可以创建多个对象

### 03. 类的设计

在程序开发中，要设计一个类，通常需要满足一下三个要素：

1. **类名** 这类事物的名字，**满足大驼峰命名法**
2. **属性** 这类事物具有什么样的特征
3. **方法** 这类事物具有什么样的行为

### 大驼峰命名法

`CapWords`

1. 每一个单词的首字母大写
2. 单词与单词之间没有下划线


**需求**

* **小明** 今年 **18 岁**，**身高 1.75**，每天早上 **跑** 完步，会去 **吃** 东西
* **小美** 今年 **17 岁**，**身高 1.65**，小美不跑步，小美喜欢 **吃** 东西 

根据上述条件创建以下类
``` 
class person
	name
	hight
	hobby
``` 
## 01. `dir` 内置函数（知道）

* 在 `Python` 中 **对象几乎是无所不在的**，我们之前学习的 **变量**、**数据**、**函数** 都是对象

在 `Python` 中可以使用以下两个方法验证：

1. 在 **标识符** / **数据** 后输入一个 `.`，然后按下 `TAB` 键，`iPython` 会提示该对象能够调用的 **方法列表**
2. 使用内置函数 `dir` 传入 **标识符** / **数据**，可以查看对象内的 **所有属性及方法**

**提示** `__方法名__` 格式的方法是 `Python` 提供的 **内置方法 / 属性**，稍后会给大家介绍一些常用的 内置方法 / 属性

| 序号 | 方法名 | 类型 | 作用 |
| :---: | :---: | :---: | --- | 
| 01 | `__new__` | 方法 | **创建对象**时，会被 **自动** 调用 |
| 02 | `__init__` | 方法 | **对象被初始化**时，会被 **自动** 调用 |
| 03 | `__del__` | 方法 | **对象被从内存中销毁**前，会被 **自动** 调用 |
| 04 | `__str__` | 方法 | 返回**对象的描述信息**，`print` 函数输出使用 |

**提示** 利用好 `dir()` 函数，在学习时很多内容就不需要死记硬背了

### 2.1 定义只包含方法的类

* 在 `Python` 中要定义一个只包含方法的类，语法格式如下：

```python
class 类名:

    def 方法1(self, 参数列表):
        pass
    
    def 方法2(self, 参数列表):
        pass
``` 

* 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下：

```python
对象变量 = 类名()
```

例子：
```python
class Cat:
    """这是一个猫类"""

    def eat(self):
        print("小猫爱吃鱼")

    def drink(self):
        print("小猫在喝水")

tom = Cat()
tom2= Cat()
tom.drink()
tom.eat()
print(tom)	#输出类名和内存位置(16进制  )
print(tom2)
```
输出
小猫在喝水
小猫爱吃鱼
<__main__.Cat object at 0x0000020B361253A0>
<__main__.Cat object at 0x0000020B361253A0>
内存相同，实际是对类的引用(对象不同)
主程序只负责让对象工作
> 在面向对象开发中，**引用**的概念是同样适用的！

* 在 `Python` 中使用类 **创建对象之后**，`tom` 变量中 仍然记录的是 **对象在内存中的地址**
* 也就是 `tom` 变量 **引用** 了 **新建的猫对象**
* 使用 `print` 输出 **对象变量**，默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 **在内存中的地址** 

### 3.2 使用 `self` 在方法内部输出每一只猫的名字

> 由 **哪一个对象** 调用的方法，方法内的 `self` 就是 **哪一个对象的引用**

* 在类封装的方法内部，`self` 就表示 **当前调用方法的对象自己**
* **调用方法时**，程序员不需要传递 `self` 参数
* **在方法内部**
    * 可以通过 `self.` **访问对象的属性**
    * 也可以通过 `self.` **调用其他的对象方法**
* 改造代码如下：

```python
class Cat:
	
    def eat(self):
        print("%s 爱吃鱼" % self.name)

tom = Cat()
tom.name = "Tom"
tom.eat()

lazy_cat = Cat()
lazy_cat.name = "大懒猫"
lazy_cat.eat()
```
使用self方法得到属性

* 在 **类的外部**，通过 `变量名.` 访问对象的 **属性和方法**
* 在 **类封装的方法中**，通过 `self.` 访问对象的 **属性和方法**
* 对象应该包含有哪些属性，应该 **封装在类的内部**

### 4.3 在初始化方法内部定义属性

* 在 `__init__` 方法内部使用 `self.属性名 = 属性的初始值` 就可以 **定义属性**
* 定义属性之后，再使用 `Cat` 类创建的对象，都会拥有该属性

```python
class Cat:

    def __init__(self,new_name):

        print("这是一个初始化方法")
        
        # 定义用 Cat 类创建的猫对象都有一个 name 的属性
        self.name = new_name

    def eat(self):
        print("%s 爱吃鱼" % self.name)

# 使用类名()创建对象的时候，会自动调用初始化方法 __init__
tom = Cat(tom)

tom.eat()

```

向方法传入形参即可得到形参 



## 05. 内置方法和属性

| 序号 | 方法名 | 类型 | 作用 |
| :---: | :---: | :---: | --- | 
| 01 | `__del__` | 方法 | **对象被从内存中销毁**前，会被 **自动** 调用 |
| 02 | `__str__` | 方法 | 返回**对象的描述信息**，`print` 函数输出使用 |

### 5.1 `__del__` 方法（知道）

* 在 `Python` 中
    * 当使用 `类名()` 创建对象时，为对象 **分配完空间**后，**自动** 调用 `__init__` 方法
    * 当一个 **对象被从内存中销毁** 前，会 **自动** 调用 `__del__` 方法

* **应用场景**
    * `__init__` 改造初始化方法，可以让创建对象更加灵活
    * `__del__` 如果希望在对象被销毁前，再做一些事情，可以考虑一下 `__del__` 方法
  * 在对象的生命周期内，可以访问对象属性，或者让对象调用方法

```python
class Cat:

    def __init__(self, new_name):

        self.name = new_name

        print("%s 来了" % self.name)

    def __del__(self):

        print("%s 去了" % self.name)
    def __str__(self):
        return	'我是小猫: %s'%self.name #必须返回字符串
# tom 是一个全局变量
tom = Cat("Tom")
print(tom.name)
print(tom)
# del 关键字可以删除一个对象
del tom

print("-" * 50)

``` 
使用__str__,可以改变print的内容

del后对象生命周期结束，调用__del__方法

```python

class man:
    def __init__(self,name,weight):
        self.name=name
        self.weight=weight
    def __str__(self):
        return '%s现在%.1f斤' %(self.name ,self.weight)
    def run(self):
        self.weight-=0.5
    def eat(self):
        self.weight+=1

ming=man('小明',75)
ming.run()
print(ming)
ming.eat()
print(ming)
```

创建小明对象并调用方法 



### 类的嵌套
一个类的属性可以是另外一个类的对象


```python
class Gun:

    def __init__(self, model):

        # 1. 枪的型号
        self.model = model

        # 2. 子弹的数量
        self.bullet_count = 0

    def add_bullet(self, count):

        self.bullet_count += count

    def shoot(self):

        # 1. 判断子弹数量
        if self.bullet_count <= 0:
            print("[%s] 没有子弹了..." % self.model)

            return

        # 2. 发射子弹，-1
        self.bullet_count -= 1

        # 3. 提示发射信息
        print("[%s] 突突突... [%d]" % (self.model, self.bullet_count))


class Soldier:

    def __init__(self, name):

        # 1. 姓名
        self.name = name

        # 2. 枪 - 新兵没有枪
        self.gun = None

    def fire(self):

        # 1. 判断士兵是否有枪
        # if self.gun == None:
        if self.gun is None:		#is――身份运算符，判断对象是否为同一对象
            print("[%s] 还没有枪..." % self.name)

            return

        # 2. 高喊口号
        print("冲啊...[%s]" % self.name)

        # 3. 让枪装填子弹
        self.gun.add_bullet(50)

        # 4. 让枪发射子弹
        self.gun.shoot()

# 1. 创建枪对象
ak47 = Gun("AK47")

# 2. 创建许三多
xusanduo = Soldier("许三多")

xusanduo.gun = ak47
xusanduo.fire()

print(xusanduo.gun)
```

如上，避免了在外面添加新的类，而是在类内初始化(赋值None)，然后再在类外赋值
is――身份运算符，判断对象是否为同一对象(引用对象是否为同一个)

```
self.__变量名
```
在变量名前面加个__(两个下划线)即可定义私有属性，仅可被类的内置函数访问,私有方法同理

## 01. 单继承

### 1.1 继承的概念、语法和特点

**继承的概念**：**子类** 拥有 **父类** 的所有 **方法** 和 **属性**

#### 1) 继承的语法

```python
class 类名(父类名):
# Dog继承Animal		 class Dog(Animal):
    pass
```

* **子类** 继承自 **父类**，可以直接 **享受** 父类中已经封装好的方法，不需要再次开发
* **子类** 中应该根据 **职责**，封装 **子类特有的** **属性和方法**

#### 2) 专业术语

* `Dog` 类是 `Animal` 类的**子类**，`Animal` 类是 `Dog` 类的**父类**，`Dog` 类从 `Animal` 类**继承**
* `Dog` 类是 `Animal` 类的**派生类**，`Animal` 类是 `Dog` 类的**基类**，`Dog` 类从 `Animal` 类**派生**

#### 3) 继承的传递性

* `C` 类从 `B` 类继承，`B` 类又从 `A` 类继承
* 那么 `C` 类就具有 `B` 类和 `A` 类的所有属性和方法

**子类** 拥有 **父类** 以及 **父类的父类** 中封装的所有 **属性** 和 **方法**

**提问**

**哮天犬** 能够调用 `Cat` 类中定义的 `catch` 方法吗？

**答案**

**不能**，因为 **哮天犬** 和 `Cat` 之间没有 **继承** 关系
```python
class Animal:

    def eat(self):
        print("吃---")

    def drink(self):
        print("喝---")

    def run(self):
        print("跑---")

    def sleep(self):
        print("睡---")


class Dog(Animal):

    # 子类拥有父类的所有属性和方法
    # def eat(self):
    #     print("吃")
    #
    # def drink(self):
    #     print("喝")
    #
    # def run(self):
    #     print("跑")
    #
    def sleep(self):
        print("睡觉") #使用了和父类同名的方法，达成重写(override)
        super().sleep()
        Animal.sleep(self)

    def bark(self):
        print("汪汪叫")


# 创建一个对象 - 狗对象
wangcai = Dog()

wangcai.eat()
wangcai.drink()
wangcai.run()
wangcai.sleep()
wangcai.bark()
```
和原不继承的对比，简洁好多
Dog继承了Animal
当 **父类** 的方法实现不能满足子类需求时，可以对方法进行 **重写(override)**
如上重写了sleep方法,并使用super().sleep和 Animal.sleep(self)使用了父类的sleep
注意，别在子类中递归调用子类方法，会无限循环 

继承的私有：
1. **子类对象** **不能** 在自己的方法内部，**直接** 访问 父类的 **私有属性** 或 **私有方法**
2. **子类对象** 可以通过 **父类** 的 **公有**方法 **间接** 访问到 **私有属性** 或 **私有方法**

> * **私有属性、方法** 是对象的隐私，不对外公开，**外界** 以及 **子类** 都不能直接访问
> * **私有属性、方法** 通常用于做一些内部的事情

## 02. 多继承

**概念**

* **子类** 可以拥有 **多个父类**，并且具有 **所有父类** 的 **属性** 和 **方法**
* 例如：**孩子** 会继承自己 **父亲** 和 **母亲** 的 **特性**


**语法**

```python
class 子类名(父类名1, 父类名2...): 
    pass
```

**问题的提出**

* 如果 **不同的父类** 中存在 **同名的方法**，**子类对象** 在调用方法时，会调用 **哪一个父类中**的方法呢？

> 提示：**开发时，应该尽量避免这种容易产生混淆的情况！** ―― 如果 **父类之间** 存在 **同名的属性或者方法**，应该 **尽量避免** 使用多继承
原则上会直接调用继承时前面的类的  同名方法，但是最好别这么用，不要降低可读性


#### Python 中的 MRO ―― 方法搜索顺序（知道）
这也是上面会使用前面的同名方法的原因
* `Python` 中针对 **类** 提供了一个 **内置属性** `__mro__` 可以查看 **方法** 搜索顺序
* MRO 是 `method resolution order`，主要用于 **在多继承时判断 方法、属性 的调用 路径**

```python
print(C.__mro__)
```

**输出结果**

```
(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
```

* 在搜索方法时，是按照 `__mro__` 的输出结果 **从左至右** 的顺序查找的
* 如果在当前类中 **找到方法，就直接执行，不再搜索**
* 如果 **没有找到，就查找下一个类** 中是否有对应的方法，**如果找到，就直接执行，不再搜索**
* 如果找到最后一个类，还没有找到方法，程序报错


### 多态
3. **多态** 不同的 **子类对象** 调用相同的 **父类方法**，产生**不同的执行结果** 
    * **多态** 可以 **增加代码的灵活度**
    * 以 **继承** 和 **重写父类方法** 为前提
    * 是调用方法的技巧，**不会影响到类的内部设计**
```
class Dog():
    def __init__(self,name):
        self.name=name

    def game(self):
        print('玩')
class S_Dog(Dog):
    def game(self):
        print('飞了')

class human():
    def __init__(self,name):
        self.name=name
    def paly_with_dog(self,dog):
        print('%s和%s玩' %(self.name,dog.name))
        dog.game()

ming=human('小明')
dog=Dog('旺财')
dog2=S_Dog('会飞的旺财')
ming.paly_with_dog(dog)
ming.paly_with_dog(dog2)
```


# 类属性和类方法

## 目标

* 类的结构
* 类属性和实例属性
* 类方法和静态方法

## 01. 类的结构

### 1.1 术语 ―― 实例

1. 使用面相对象开发，**第 1 步** 是设计 **类**
2. 使用 **类名()** 创建对象，**创建对象** 的动作有两步：
    * 1) 在内存中为对象 **分配空间**
    * 2) 调用初始化方法 `__init__` 为 **对象初始化**
3. 对象创建后，**内存** 中就有了一个对象的 **实实在在** 的存在 ―― **实例**
 
因此，通常也会把：

1. 创建出来的 **对象** 叫做 **类** 的 **实例**
2. 创建对象的 **动作** 叫做 **实例化**
3. **对象的属性** 叫做 **实例属性**
4. **对象调用的方法** 叫做 **实例方法**

在程序执行时：

1. 对象各自拥有自己的 **实例属性**
2. 调用对象方法，可以通过 `self.` 
    * 访问自己的属性
    * 调用自己的方法

**结论**

* **每一个对象** 都有自己 **独立的内存空间**，**保存各自不同的属性**
* **多个对象的方法**，**在内存中只有一份**，在调用方法时，**需要把对象的引用** 传递到方法内部

### 1.2 类是一个特殊的对象

> `Python` 中 **一切皆对象**：
> 
> * `class AAA:` 定义的类属于 **类对象**
> * `obj1 = AAA()` 属于 **实例对象**

* 在程序运行时，**类** 同样 **会被加载到内存**
* 在 `Python` 中，**类** 是一个特殊的对象 ―― **类对象**
* 在程序运行时，**类对象** 在内存中 **只有一份**，使用 **一个类** 可以创建出 **很多个对象实例**
* 除了封装 **实例** 的 **属性** 和 **方法**外，**类对象** 还可以拥有自己的 **属性** 和 **方法**
    1. **类属性**
    2. **类方法**
* 通过 **类名.** 的方式可以 **访问类的属性** 或者 **调用类的方法**

## 02. 类属性和实例属性

### 2.1 概念和使用

* **类属性** 就是给 **类对象** 中定义的 **属性**
* 通常用来记录 **与这个类相关** 的特征
* **类属性** **不会用于**记录 **具体对象的特征**

**示例需求**

* 定义一个 **工具类**
* 每件工具都有自己的 `name`
* **需求** ―― 知道使用这个类，创建了多少个工具对象？

如下：
```python
class Tool(object):

    # 使用赋值语句，定义类属性，记录创建工具对象的总数
    count = 0

    def __init__(self, name):
        self.name = name

        # 针对类属性做一个计数+1
        Tool.count += 1


# 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")
tool3 = Tool("铁锹")
tool3.count=99
# 知道使用 Tool 类到底创建了多少个对象?
print("现在创建了 %d 个工具" % tool3.count)
print("现在创建了 %d 个工具" % Tool.count)

```

利用count统计了创建多少个Tool对象，仅对Tool本身有反馈，改变tool3.count不会改变Tool.count的值

### 2.2 属性的获取机制（科普）

* 在 `Python` 中 **属性的获取** 存在一个 **向上查找机制**，先在对象中找，没有再向上找
![向上寻找机制](D:\numpy%2Bdeep%20learning\向上寻找机制.png)
* 因此，要访问**类属性**有两种方式：
    1. **类名.类属性**
    2. **对象.类属性** （不推荐）

**注意**

* 如果使用 `对象.类属性 = 值` 赋值语句，只会 **给对象添加一个属性**，而不会影响到 **类属性的值**

## 03. 类方法和静态方法

### 3.1 类方法

* **类属性** 就是针对 **类对象** 定义的属性(只能访问类属性，实例方法可以访问所有属性)
    * 使用 **赋值语句** 在 `class` 关键字下方可以定义 **类属性**
    * **类属性** 用于记录 **与这个类相关** 的特征
* **类方法** 就是针对 **类对象** 定义的方法
    * 在 **类方法** 内部可以直接访问 **类属性** 或者调用其他的 **类方法**

**语法如下**

```python
@classmethod
def 类方法名(cls):
    print(cls.变量名)	#不用self. 而是用cls.来调用类属性
```

* 类方法需要用 **修饰器** `@classmethod` 来标识，**告诉解释器这是一个类方法**
* 类方法的 **第一个参数** 应该是 `cls`，不需要self参数
    * 由 **哪一个类** 调用的方法，方法内的 `cls` 就是 **哪一个类的引用**
    * 这个参数和 **实例方法** 的第一个参数是 `self` 类似
    * **提示** 使用其他名称也可以，不过习惯使用 `cls`
3. 通过 **类名.** 调用 **类方法**，**调用方法时**，不需要传递 `cls` 参数
4. **在方法内部**
    * 可以通过 `cls.` **访问类的属性**
    * 也可以通过 `cls.` **调用其他的类方法**

**示例需求**
 
* 定义一个 **工具类** 
* 每件工具都有自己的 `name`
* **需求** ―― 在 **类** 封装一个 `show_tool_count` 的类方法，输出使用当前这个类，创建的对象个数 

### 3.2 静态方法

* 在开发时，如果需要在 **类** 中封装一个方法，这个方法：
    * 既 **不需要** 访问 **实例属性** 或者调用 **实例方法**
    * 也 **不需要** 访问 **类属性** 或者调用 **类方法**
    
* 这个时候，可以把这个方法封装成一个 **静态方法**

**语法如下**

```python
@staticmethod
def 静态方法名():
    pass
```

* **静态方法** 需要用 **修饰器** `@staticmethod` 来标识，**告诉解释器这是一个静态方法**
* 通过 **类名.** 调用 **静态方法**  























































































